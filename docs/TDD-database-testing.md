# Technical Design Documentâ€”Database Testing

## Decisions
* Tests of repositories MUST hit actual database
* Database have to be freshly truncated and migrated before running test suite(s)
* Use `typeorm-transactional-tests` in an attempt to eliminate test side effects and allow parallel integration/e2e testing

## Reasoning
* migration of test database vs TypeOrm schema sync 
  * While TypeOrm have ability to sync its database schema to database - it cannot be trusted 
    * While TypeOrm have ability to generate migrations from schema, they will be manually changed
    * While TypeOrm have ability to generate migrations from schema, there will be migrations written by hand
    * While TypeOrm have ability to generate migrations from schema, it is imperfect - so it may & will contain errors
      * Therefore, to ensure that we are testing against production schema, not some approximation of it
        * Database have to be freshly truncated and migrated before running test suite(s)
        * Tests of repositories MUST hit actual database
          * Mocking TypeOrm repositories: 
            * do not tell us if migrates schema is ok
            * tells us nothing about correctness of raw sql queries we might perform to optimize database reads/writes
* Parallel testing vs single runner
  * parallel testing comes with a lot of complexity (complex, fast)
    * way out: easy to switch to single-runner approach at any time  
    * test runner spawns multiple workers, running test suites one by one, each running tests one by one
      * either: 
        * each test suite have no side effects
          * truncate after each test & each runner have its own database (possibly slow)
            * Ref: https://blog.mikevosseller.com/2021/11/25/how-to-run-jest-with-multiple-test-databases.html
              * Approach described uses schema sync - which is no go, but describes well how to get Jest workers running with multiple dbs 
          * wrap each test in transaction, which is rolled back after test completion (complex)
        * tests are designed from the start to not interfere with each other (unreliable)
          * all test fixtures have autogenerated, random data with high entropy so collisions are unlikely when it comes to constrained data fields 
            * i.e. `${uuid_v4()@gmail.com}` as email when it comes to user which have a unique email constraint 
          * when it comes to reporting/listing both endpoints and repositories have ability to limit processed data to provided set of id's 
            * i.e. when testing pagination, test can limit paginated list to only fixtures it created 
  * single runner (simple, slow, easier to debug)
    * way out: with extensive test suite only reasonable way of going parallel in the future is transactional approach (complex)
    * deal-breakers: 
      * fast suite means that it is run very often, cutting feedback-loop to minimum, both locally and in CI
      * slow suite means that it is run rarely, and can break developer flow - as I go to unpack washer or sth while it is running
* Transactional vs non-transactional testing
  * As reasoned above, transactional approach seems like best solution
    * caveat: it will be very time-consuming to implement it myself 
    * caveat: therefore, we will be depending on potentially fragile package to get it almost-out-of-the-box
    * solution: use `typeorm-transactional-tests`

 